<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>AirDraw — Front Camera, Cursor, GTA-Style Menu</title>
<style>
  :root {
    --ui-bg: rgba(0,0,0,0.45);
    --ui-fg: #fff;
  }
  html, body {
    margin: 0; padding: 0; height: 100%; background: #000; font-family: Inter, system-ui, Arial, sans-serif; overflow: hidden;
  }
  #app {
    position: relative; width: 100vw; height: 100vh; user-select: none;
  }
  video#cam {
    position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); z-index: 0;
  }
  canvas {
    position: absolute; top: 0; left: 0; touch-action: none;
  }
  #drawCanvas { z-index: 1; }
  #overlay { z-index: 2; }

  /* Cursor style */
  #cursor {
    position: fixed; width: 36px; height: 36px; border-radius: 50%;
    pointer-events: none; z-index: 70;
    transform: translate(-50%, -50%);
    box-shadow: 0 8px 20px rgba(0,0,0,0.45), inset 0 -4px 10px rgba(0,0,0,0.25);
    border: 3px solid rgba(255,255,255,0.08);
    background: rgba(255, 200, 40, 0.95);
    mix-blend-mode: screen;
    transition: background 140ms linear, transform 120ms ease;
    display: block;
  }

  /* Controls */
  #controls {
    position: fixed; left: 12px; top: 12px; z-index: 60;
    background: var(--ui-bg); padding: 8px;
    border-radius: 8px; display: flex; gap: 8px; align-items: center;
  }
  button, select, input[type=color] {
    background: transparent; border: 1px solid rgba(255,255,255,0.12);
    color: var(--ui-fg); padding: 6px 8px; border-radius: 8px;
    cursor: pointer;
  }
  #hud {
    position: fixed; right: 12px; top: 12px; z-index: 60;
    background: var(--ui-bg); color: var(--ui-fg); padding: 8px 10px;
    border-radius: 9px;
  }
  #status {
    position: fixed; left: 12px; bottom: 12px; z-index: 60;
    background: var(--ui-bg); color: var(--ui-fg); padding: 6px 10px;
    border-radius: 9px;
  }

  /* Menu button moved to top right side */
  #menuBtn {
    position: fixed; top: 12px; right: 80px; z-index: 60;
    background: rgba(255,255,255,0.06);
    border: 1px solid rgba(255,255,255,0.12);
    color: var(--ui-fg);
    padding: 10px 14px;
    border-radius: 10px;
    backdrop-filter: blur(6px);
    font-weight: 600;
    cursor: pointer;
    user-select: none;
    transition: background 0.3s ease;
  }
  #menuBtn:hover {
    background: rgba(255,255,255,0.12);
  }

</style>
</head>
<body>
<div id="app">
  <video id="cam" autoplay playsinline muted></video>

  <canvas id="drawCanvas"></canvas>
  <canvas id="overlay"></canvas>

  <div id="cursor" aria-hidden="true"></div>

  <div id="controls">
    <button id="saveBtn">Save</button>
    <button id="clearBtn">Clear</button>
    <label>Color <input id="colorPicker" type="color" value="#ff3b30"></label>
    <label>Size
      <select id="sizeSelect">
        <option value="3">S</option>
        <option value="8" selected>M</option>
        <option value="18">L</option>
      </select>
    </label>
  </div>

  <button id="menuBtn">Menyu</button>
  <div id="hud">Mode: <span id="modeText">Brush</span></div>
  <div id="status">Initializing camera...</div>
</div>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
  /* ---------- Setup ---------- */
  const video = document.getElementById('cam');
  const drawCanvas = document.getElementById('drawCanvas');
  const overlay = document.getElementById('overlay');
  const dctx = drawCanvas.getContext('2d');
  const octx = overlay.getContext('2d');
  const cursor = document.getElementById('cursor');
  const menuBtn = document.getElementById('menuBtn');
  const statusEl = document.getElementById('status');
  const hudMode = document.getElementById('modeText');
  const saveBtn = document.getElementById('saveBtn');
  const clearBtn = document.getElementById('clearBtn');
  const colorPicker = document.getElementById('colorPicker');
  const sizeSelect = document.getElementById('sizeSelect');

  let DPR = window.devicePixelRatio || 1;
  let W = window.innerWidth, H = window.innerHeight;
  function resize() {
    W = window.innerWidth; H = window.innerHeight;
    drawCanvas.width = W * DPR; drawCanvas.height = H * DPR;
    drawCanvas.style.width = W + 'px'; drawCanvas.style.height = H + 'px';
    dctx.setTransform(DPR, 0, 0, DPR, 0, 0);

    overlay.width = W * DPR; overlay.height = H * DPR;
    overlay.style.width = W + 'px'; overlay.style.height = H + 'px';
    octx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  /* ---------- State ---------- */
  let mirror = true;
  let currentMode = 'Brush';
  let brushSize = Number(sizeSelect.value);
  let color = colorPicker.value;
  let shapesMode = 'circle';
  let isDrawing = false;
  let lastPos = null;

  const palette = ['#ff3b30', '#ff9500', '#ffd60a', '#34c759', '#5ac8fa', '#5856d6', '#ff2d55'];
  let paletteIndex = 0, fiveWasOn = false;

  const SECTORS = ['Brush', 'Eraser', 'Colors', 'Size', 'Clear', 'Shapes'];
  let menuVisible = false;
  let menuCenter = { x: W / 2, y: H / 2 };
  let menuRadius = 0; // animated
  let menuTargetRadius = 0;
  let hoveredSector = null;
  let hoverStart = 0;
  const HOVER_MS = 5000; // 5 seconds

  const penThresholdPx = Math.max(36, Math.round(Math.min(W, H) * 0.06));
  const penThresholdNorm = 0.06;

  /* ---------- UI hooks ---------- */
  colorPicker.addEventListener('input', e => color = e.target.value);
  sizeSelect.addEventListener('change', e => brushSize = Number(e.target.value));

  saveBtn.onclick = () => {
    const tmp = document.createElement('canvas');
    tmp.width = W * DPR; tmp.height = H * DPR;
    const t = tmp.getContext('2d');
    t.save();
    if (mirror) {
      t.translate(tmp.width / DPR, 0);
      t.scale(-1, 1);
    }
    t.drawImage(video, 0, 0, tmp.width / DPR, tmp.height / DPR);
    t.restore();
    t.drawImage(drawCanvas, 0, 0);
    const url = tmp.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = url;
    a.download = 'airdraw.png';
    a.click();
  };
  clearBtn.onclick = () => {
    dctx.clearRect(0, 0, W, H);
  };

  /* ---------- Menu Button & Logic ---------- */

  // Move menu button to top right (already styled in CSS)

  // Hover 5 seconds on button to open menu:
  let menuHoverStart = 0;
  let menuBtnHovered = false;

  menuBtn.addEventListener('mouseenter', () => {
    menuBtnHovered = true;
    menuHoverStart = performance.now();
  });
  menuBtn.addEventListener('mouseleave', () => {
    menuBtnHovered = false;
    menuHoverStart = 0;
  });

  function openMenuCentered() {
    menuVisible = true;
    menuCenter = { x: W / 2, y: H / 2 };
    menuTargetRadius = Math.min(160, Math.max(100, Math.min(W, H) * 0.17));
    menuRadius = 0;
    hoveredSector = null;
    hoverStart = 0;
    statusEl.textContent = 'Menyu ochildi';
    isDrawing = false;
    lastPos = null;
  }
  function closeMenu() {
    menuVisible = false;
    menuTargetRadius = 0;
    hoveredSector = null;
    hoverStart = 0;
    statusEl.textContent = currentMode + ' mode';
  }

  function setMode(m) {
    currentMode = m;
    hudMode.textContent = m;
    statusEl.textContent = m + ' mode';
  }

  /* ---------- MediaPipe Hands ---------- */
  const hands = new Hands({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
  hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.65, minTrackingConfidence: 0.65 });
  hands.onResults(onHands);

  const camera = new Camera(video, {
    onFrame: async () => {
      await hands.send({ image: video });
    },
    width: 1280,
    height: 720
  });

  async function startCam() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: false });
      video.srcObject = stream;
      await video.play();
      statusEl.textContent = "Kamera yuklandi — qo'lingizni tutilang";
      camera.start();
    } catch (e) {
      console.error(e);
      statusEl.textContent = 'Camera error: ' + (e.message || e.name);
    }
  }
  startCam();

  /* ---------- Drawing & Gesture Logic ---------- */
  function normToScreen(pt) {
    let x = pt.x * W, y = pt.y * H;
    if (mirror) x = W - x;
    return { x, y };
  }

  function drawWheel(center, radius, hoverIndex) {
    const sec = SECTORS.length;
    const sectorAngle = (2 * Math.PI) / sec;
    octx.save();
    octx.globalAlpha = 0.95;
    for (let i = 0; i < sec; i++) {
      const start = i * sectorAngle - Math.PI / 2;
      const end = start + sectorAngle;
      octx.beginPath();
      octx.moveTo(center.x, center.y);
      octx.arc(center.x, center.y, radius, start, end);
      octx.closePath();
      octx.fillStyle = (i === hoverIndex) ? 'rgba(255,230,120,0.98)' : 'rgba(0,0,0,0.6)';
      octx.fill();

      // Text label
      const ang = start + sectorAngle / 2;
      const lx = center.x + Math.cos(ang) * (radius * 0.6);
      const ly = center.y + Math.sin(ang) * (radius * 0.6);
      octx.fillStyle = i === hoverIndex ? '#000' : '#fff';
      octx.font = 'bold 16px sans-serif';
      octx.textAlign = 'center';
      octx.textBaseline = 'middle';
      octx.fillText(SECTORS[i], lx, ly);
    }
    octx.restore();
  }

  function handleSectorSelect(i) {
    const s = SECTORS[i];
    switch (s) {
      case 'Brush': setMode('Brush'); break;
      case 'Eraser': setMode('Eraser'); break;
      case 'Colors':
        paletteIndex = (paletteIndex + 1) % palette.length;
        colorPicker.value = palette[paletteIndex];
        color = palette[paletteIndex];
        statusEl.textContent = 'Rang: ' + color;
        setTimeout(() => statusEl.textContent = currentMode + ' mode', 800);
        break;
      case 'Size': {
        const opts = [3, 8, 18];
        const cur = opts.indexOf(brushSize);
        const nxt = opts[(cur + 1) % opts.length];
        brushSize = nxt;
        sizeSelect.value = String(nxt);
        statusEl.textContent = 'Size: ' + nxt;
        setTimeout(() => statusEl.textContent = currentMode + ' mode', 700);
        break;
      }
      case 'Clear':
        dctx.clearRect(0, 0, W, H);
        statusEl.textContent = 'Cleared';
        setTimeout(() => statusEl.textContent = currentMode + ' mode', 700);
        break;
      case 'Shapes':
        setMode('Shapes');
        shapesMode = (shapesMode === 'circle') ? 'square' : 'circle';
        statusEl.textContent = 'Shapes: ' + shapesMode;
        setTimeout(() => statusEl.textContent = currentMode + ' mode', 700);
        break;
    }
    if (navigator.vibrate) navigator.vibrate(40);
  }

  // Main handler
  function onHands(results) {
    octx.clearRect(0, 0, W, H);

    // Handle menu button hover timer:
    if (menuBtnHovered) {
      if (!menuVisible && performance.now() - menuHoverStart > HOVER_MS) {
        openMenuCentered();
      }
    } else {
      menuHoverStart = 0;
    }

    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
      cursor.style.display = 'none';
      statusEl.textContent = "Qo'l topilmadi";
      hoverStart = 0;
      hoveredSector = null;
      fiveWasOn = false;
      isDrawing = false;
      lastPos = null;
      return;
    }

    const lm = results.multiHandLandmarks[0];
    const idx = normToScreen(lm[8]);
    cursor.style.left = idx.x + 'px';
    cursor.style.top = idx.y + 'px';
    cursor.style.display = 'block';

    // Cursor color states
    let cursorColor = 'rgba(255,200,40,0.95)';
    if (menuVisible) cursorColor = 'rgba(80,200,220,0.95)';
    if (hoveredSector !== null && menuVisible) cursorColor = 'rgba(80,230,120,0.98)';
    if (isDrawing) cursorColor = 'rgba(255,100,100,0.95)';
    cursor.style.background = cursorColor;
    cursor.style.transform = 'translate(-50%, -50%) scale(' + (menuVisible ? 1.05 : 1) + ')';

    // Small overlay ring under cursor
    octx.beginPath();
    octx.arc(idx.x, idx.y, 10, 0, 2 * Math.PI);
    octx.fillStyle = 'rgba(255,255,255,0.05)';
    octx.fill();

    // Gestures detection
    const thumb = lm[4];
    const middle = lm[12];
    const dx = lm[8].x - thumb.x;
    const dy = lm[8].y - thumb.y;
    const distNorm = Math.hypot(dx, dy);
    const approxPxDist = distNorm * Math.min(W, H);
    const penDown = (approxPxDist < penThresholdPx) || (distNorm < penThresholdNorm);

    // Five fingers detection -> palette cycle
    let extendedCount = 0;
    const fingerPairs = [{ tip: 8, pip: 6 }, { tip: 12, pip: 10 }, { tip: 16, pip: 14 }, { tip: 20, pip: 18 }];
    for (const f of fingerPairs) if (lm[f.tip].y < lm[f.pip].y) extendedCount++;
    const thumbIp = lm[3];
    const thumbExt = mirror ? (lm[4].x > thumbIp.x + 0.03) : (lm[4].x < thumbIp.x - 0.03);
    if (thumbExt) extendedCount++;
    if (extendedCount === 5 && !fiveWasOn) {
      paletteIndex = (paletteIndex + 1) % palette.length;
      colorPicker.value = palette[paletteIndex];
      color = palette[paletteIndex];
      fiveWasOn = true;
      if (navigator.v
